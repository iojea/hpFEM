// @bun
var g=Object.defineProperty;var o=(N,_)=>{for(var K in _)g(N,K,{get:_[K],enumerable:!0,configurable:!0,set:(O)=>_[K]=()=>O})};import n from"events";import{appendFileSync as r} from"fs";import{parseArgs as i} from"util";var C={openai:"Continue the input code from the language <languageId>. Only respond with code.",copilot:"<languageId> completions. Only respond with code."};var V=[{key:"generateDocs",label:"Generate documentation",query:"Add documentation to this code."},{key:"improveCode",label:"Improve code",query:"Improve this code."},{key:"refactorFromComment",label:"Refactor code from a comment",query:"Refactor this code based on the comment."},{key:"writeTest",label:"Write a unit test",query:"Write a unit test for this code. Do not include any imports."}];var m=(N)=>{const _=new URLSearchParams(N);return Object.fromEntries(_.entries())},a=async()=>{const N=await fetch("https://github.com/login/device/code?client_id=Iv1.b507a08c87ecfe98&scope=read:user",{method:"POST",headers:{"Content-Type":"application/json"}});if(!N.ok)throw new Error(`fetchDeviceCode failed: ${N.status} ${await N.text()}`);return m(await N.text())},E=async()=>{const N=await a();console.log(`Visit: ${N.verification_uri} in your browser and enter: ${N.user_code}`);while(!0){await new Promise((O)=>setTimeout(O,5000));const _=await fetch(`https://github.com/login/oauth/access_token?client_id=Iv1.b507a08c87ecfe98&device_code=${N.device_code}&grant_type=urn:ietf:params:oauth:grant-type:device_code`,{method:"POST",headers:{"Content-Type":"application/json"}}),K=m(await _.text());if(K?.access_token?.length){console.log("\n\nGot token:",K.access_token,"\n\n","Store this in the COPILOT_API_KEY environment variable");break}console.log("Waiting for user authorization...")}};var{values:w}=i({args:Bun.argv,options:{logFile:{type:"string",default:Bun.env.LOG_FILE??""},handler:{type:"string",default:Bun.env.HANDLER??"openai"},openaiKey:{type:"string",default:Bun.env.OPENAI_API_KEY},openaiContext:{type:"string",default:Bun.env.OPENAI_CONTEXT?.length?Bun.env.OPENAI_CONTEXT:C.openai},openaiModel:{type:"string",default:Bun.env.OPENAI_MODEL??"gpt-3.5-turbo-16k"},openaiMaxTokens:{type:"string",default:Bun.env.OPENAI_MAX_TOKENS??"7000"},openaiEndpoint:{type:"string",default:Bun.env.OPENAI_ENDPOINT??"https://api.openai.com/v1/chat/completions"},copilotEndpoint:{type:"string",default:Bun.env.GITHUB_ENDPOINT??"https://api.githubcopilot.com"},copilotContext:{type:"string",default:Bun.env.COPILOT_CONTEXT?.length?Bun.env.COPILOT_CONTEXT:C.copilot},copilotModel:{type:"string",default:Bun.env.COPILOT_MODEL??"gpt-3.5-turbo"},copilotApiKey:{type:"string",default:Bun.env.COPILOT_API_KEY},authCopilot:{type:"boolean",default:!1}},strict:!0,allowPositionals:!0});if(w.authCopilot)await E(),process.exit(0);if(!Bun.env.TEST_RUNNER?.length&&!w.openaiKey?.length&&!w.copilotApiKey?.length)throw new Error("no handler key provided");var W=w;import s from"crypto";var L={},h=(N,_,K)=>{if(L[N])clearTimeout(L[N]);L[N]=setTimeout(_,K)};var J=(N)=>{return s.randomBytes(N/2).toString("hex")},f=async(N,_,K)=>{const O=N?.split("\n").slice(0,_+1);O[O.length-1]=O[O.length-1].split("").slice(0,K).join("");const R=O[O.length-1],z=O.join("\n"),$=N?.split("\n").slice(_+1).join("\n"),j=z.slice(-1);return{contentBefore:z,contentAfter:$,lastCharacter:j,lastLine:R}},Y=(...N)=>{if(!W.logFile)return;if(Bun.env.TEST_RUNNER)console.log(y(...N));else if(W.logFile?.length)try{r(W.logFile,y(...N)+"\n\n")}catch(_){}},y=(...N)=>{let _=[];return N.forEach((K)=>{_.push(K),_.push("|")}),_=_.slice(0,_.length-1),["APP",(new Date()).toISOString(),"-->",..._].join(" ")},S=(N)=>{return Array.from(new Set(N))},b=(N)=>{if(!N?.length)return{};const _={},K=N.split(";");for(let O of K){const[R,z]=O.split("=");_[R]=z}return _},k=()=>{return Math.floor(Date.now()/1000)},v=(N,_,K)=>{const O=new RegExp(`\`\`\`${K}([\\s\\S]*?)\`\`\``,"g");let R;const z=[];while((R=O.exec(_))!==null)z.push(R[0]);const $=z[0];if(!$?.length)return;const j=$?.replace(`// FILEPATH: ${N.replace("file://","")}\n`,"")?.split("\n");return j?.slice(1,j.length-1)?.join("\n")+"\n"};var X;(function(G){G["DidOpen"]="textDocument/didOpen";G["DidChange"]="textDocument/didChange";G["Completion"]="textDocument/completion";G["CodeAction"]="textDocument/codeAction";G["ApplyEdit"]="workspace/applyEdit";G["ExecuteCommand"]="workspace/executeCommand";G["Initialize"]="initialize";G["Shutdown"]="shutdown";G["Exit"]="exit";G["PublishDiagnostics"]="textDocument/publishDiagnostics"})(X||(X={}));var A;(function(R){R[R["Error"]=1]="Error";R[R["Warning"]=2]="Warning";R[R["Information"]=3]="Information";R[R["Hint"]=4]="Hint"})(A||(A={}));class q{emitter;capabilities;currentUri;buffers;constructor({capabilities:N}){this.emitter=new n,this.capabilities=N,this.buffers={},this.registerDefault()}registerDefault(){this.on(X.Initialize,async({ctx:N})=>{N.send({method:X.Initialize,id:0,result:{capabilities:this.capabilities}})}),this.on(X.DidOpen,({ctx:N,request:_})=>{const{uri:K,text:O,languageId:R}=_.params.textDocument;this.buffers[K]={uri:K,text:O,languageId:R,version:0},this.currentUri=K,Y("received didOpen",`language: ${R}`)}),this.on(X.Shutdown,()=>{Y("received shutdown request"),process.exit(0)}),this.on(X.DidChange,async({ctx:N,request:_})=>{const{uri:K,version:O}=_.params.textDocument;this.buffers[K].version=O,this.currentUri=K,_.params.contentChanges.forEach((R)=>{this.positionalUpdate(K,R.text,R.range)}),Y("received didChange",`language: ${this.buffers[K].languageId}`,`contentVersion: ${O}`,`uri: ${K}`)})}registerEventHandlers(N){Object.values(N).forEach((_)=>{_(this)})}getContentFromRange(N){Y("getting content from range",JSON.stringify(N),`uri: ${this.currentUri}`,`current buffers: ${JSON.stringify(Object.keys(this.buffers))}`);const{start:_,end:K}=N;return this.buffers[this.currentUri]?.text?.split("\n")?.slice(_.line,K.line+1).join("\n")}positionalUpdate(N,_,K){const R=this.buffers[N]?.text?.split("\n"),z=K.start.line,$=K.end.line,j=R[z],P=R[$],U=j?.substring(0,K.start.character),G=P?.substring(K.end.character),T=[U+_+G],F=R.reduce((I,Q,M)=>{if(M<z||M>$)I.push(Q);else if(M===z)I.push(T[0]);return I},[]);this.buffers[N].text=F.join("\n")}on(N,_){const K=this;this.emitter.on(N,async(O)=>{try{_({ctx:K,request:O})}catch(R){Y("error in event",JSON.stringify(O),R.message)}})}send({method:N,id:_,result:K,params:O}){const R=JSON.stringify({jsonrpc:"2.0",method:N,id:_,result:K,params:O});console.log(`Content-Length: ${R.length}\r\n\r\n${R}`),Y("sent request",R)}sendDiagnostics(N,_=0){Y("sending diagnostics",JSON.stringify(N));const K={uri:this.currentUri,diagnostics:N.map((O)=>{return O.source="helix-gpt",O})};if(this.send({method:X.PublishDiagnostics,params:K}),_>0)setTimeout(()=>{this.send({method:X.PublishDiagnostics,params:{uri:this.currentUri,diagnostics:[]}})},_)}resetDiagnostics(){this.send({method:X.PublishDiagnostics,params:{uri:this.currentUri,diagnostics:[]}})}parseLine(N){const _=N.split("\r\n");for(let K of _)try{return JSON.parse(K)}catch(O){}throw new Error("failed to parse")}async receiveLine(N){try{const _=this.parseLine(N);if(![X.DidChange,X.DidOpen].includes(_.method))Y("received request:",JSON.stringify(_));this.emitter.emit(_.method,_)}catch(_){Y("failed to parse line:",_.message,N)}}async start(){for await(let N of Bun.stdin.stream()){const _=Buffer.from(N).toString();this.receiveLine(_)}}}var Z={Service:q,Event:X,DiagnosticSeverity:A};var H={};o(H,{completions:()=>{{return _N}},actions:()=>{{return NN}}});var x=async(N,_,K)=>{Y("sending completion request",JSON.stringify(K));const O=await fetch(N,{method:"POST",headers:_,body:JSON.stringify(K)});if(!O.ok)throw Y("completion error",O.status,await O.text()),new Error("request error with status code "+O.status);return O},t=async(N,_,K)=>{return(await(await x(N,_,K)).json())?.choices?.map((z)=>z.message?.content)},e=async(N,_,K)=>{const z=(await(await x(N,_,K)).text()).split("\n").map(($)=>$.slice(5)).map(($)=>{try{return JSON.parse($).choices[0]}catch(j){return null}}).filter(($)=>$).reduce(function($,j){return $[j.index]=$[j.index]||[],$[j.index].push(j),$},Object.create(null));return Object.values(z).map(($)=>$.map((j)=>j.text).join(""))},D={stream:e,standard:t};var B,d={openai:async(N,_,K,O=3)=>{const R=[{role:"system",content:W.openaiContext.replace("<languageId>",K)+"\n\n"+`End of file context:\n\n${N.contentAfter}`},{role:"user",content:`Start of file context:\n\n${N.contentBefore}`}],z={model:W.openaiModel,max_tokens:parseInt(W.openaiMaxTokens),n:O,temperature:1,top_p:0.7,frequency_penalty:1,presence_penalty:2,messages:R},$={Authorization:`Bearer ${W.openaiKey}`,"Content-Type":"application/json"};return await D.standard(W.openaiEndpoint,$,z)},copilot:async(N,_,K,O=3)=>{const R=b(B);if(!R?.exp||parseInt(R.exp)<=k()){Y("refreshing copilot token");const j=await fetch("https://api.github.com/copilot_internal/v2/token",{headers:{Authorization:`Bearer ${W.copilotApiKey}`}});if(!j.ok)throw Y("failed to refresh copilot token",j.status,await j.text()),new Error("failed to refresh copilot token: "+j.status);const{token:P}=await j.json();B=P,Y("updated token")}const z={"Content-Type":"application/json; charset=utf-8","User-Agent":"GithubCopilot/1.155.0",Authorization:`Bearer ${B}`,"Editor-Plugin-Version":"copilot/1.155.0","Editor-Version":"vscode/1.85.1","Openai-Intent":"copilot-ghost","Openai-Organization":"github-copilot","VScode-MachineId":J(64),"VScode-SessionId":J(8)+"-"+J(4)+"-"+J(4)+"-"+J(4)+"-"+J(25),"X-Request-Id":J(8)+"-"+J(4)+"-"+J(4)+"-"+J(4)+"-"+J(12),"Accept-Encoding":"gzip,deflate,br",Accept:"*/*"},$={extra:{language:K,next_indent:0,prompt_tokens:500,suffix_tokens:400,trim_by_indentation:!0},max_tokens:500,n:O,nwo:"app",prompt:`// Path: ${_.replace("file://","")}\n${N.contentBefore}`,stop:["\n\n"],stream:!0,suffix:N.contentAfter,temperature:O>1?0.4:0,top_p:1};try{const j=await D.stream("https://copilot-proxy.githubusercontent.com/v1/engines/copilot-codex/completions",z,$);return Y("got copilot completion result",j),j}catch(j){throw Y("copilot request failed: "+j.message),j}}},p={copilot:async(N,_,K,O)=>{const R=b(B);if(!R?.exp||parseInt(R.exp)<=k()){Y("refreshing copilot token");const P=await fetch("https://api.github.com/copilot_internal/v2/token",{headers:{Authorization:`Bearer ${W.copilotApiKey}`}});if(!P.ok)throw Y("failed to refresh copilot token",P.status,await P.text()),new Error("failed to refresh copilot token: "+P.status);const{token:U}=await P.json();B=U,Y("updated token")}const $={intent:!0,max_tokens:7909,model:"gpt-3.5-turbo",n:1,stream:!1,temperature:0.1,top_p:1,messages:[{content:`You are an AI programming assistant.\nWhen asked for your name, you must respond with \"GitHub Copilot\".\nFollow the user's requirements carefully & to the letter.\n- Each code block starts with \`\`\` and // FILEPATH.\n- You always answer with ${O} code.\n- When the user asks you to document something, you must answer in the form of a ${O} code block.\nYour expertise is strictly limited to software development topics.\nFor questions not related to software development, simply give a reminder that you are an AI programming assistant.\nKeep your answers short and impersonal.`,role:"system"},{content:`I have the following code in the selection:\n\`\`\`${O}\n// FILEPATH: ${K.replace("file://","")}\n${_}`,role:"user"},{content:N,role:"user"}]},j={"Content-Type":"application/json; charset=utf-8","User-Agent":"GitHubCopilotChat/0.8.0",Authorization:`Bearer ${B}`,"Editor-Plugin-Version":"copilot-chat/0.8.0","Editor-Version":"vscode/1.83.1","Openai-Intent":"conversation-panel","Openai-Organization":"github-copilot","VScode-MachineId":J(64),"VScode-SessionId":J(8)+"-"+J(4)+"-"+J(4)+"-"+J(4)+"-"+J(25),"X-Request-Id":J(8)+"-"+J(4)+"-"+J(4)+"-"+J(4)+"-"+J(12),"Accept-Encoding":"gzip,deflate,br",Accept:"*/*",Connection:"close"};try{const P=await D.standard(W.copilotEndpoint+"/chat/completions",j,$);return Y("got copilot chat result:",P),v(K,P,O)}catch(P){throw Y("copilot request failed: "+P.message),P}}},u=async(N,_,K,O)=>{if(!p[W.handler])throw Y("chat handler does not exist"),new Error(`chat handler: ${W.handler} does not exist`);O=O??"unknown";try{return Y("running chat handler:",W.handler),await p[W.handler](N,_,K,O)}catch(R){throw Y("chat failed",R.message),new Error("Chat failed: "+R.message)}},l=async(N,_,K,O=3)=>{if(!d[W.handler])throw Y("completion handler does not exist"),new Error(`completion handler: ${W.handler} does not exist`);K=K??"unknown";try{return Y("running completion handler:",W.handler),S(await d[W.handler](N,_,K,O))}catch(R){throw Y("completion failed",R.message),new Error("Completion failed: "+R.message)}};var NN=(N)=>{N.on(Z.Event.ExecuteCommand,async({ctx:_,request:K})=>{const{command:O}=K.params,{range:R,query:z}=K.params.arguments[0];_.sendDiagnostics([{message:`Executing ${O}...`,range:R,severity:Z.DiagnosticSeverity.Information}],1e4);const $=_.getContentFromRange(R),j=_.buffers[_.currentUri];try{var P=await u(z,$,_.currentUri,j?.languageId);if(!P?.length)throw new Error("No completion found")}catch(U){return Y("chat failed",U.message),_.sendDiagnostics([{message:U.message,severity:Z.DiagnosticSeverity.Error,range:R}],1e4)}Y("received chat result:",P),_.send({method:Z.Event.ApplyEdit,id:K.id,params:{label:O,edit:{changes:{[_.currentUri]:[{range:R,newText:P}]}}}}),_.resetDiagnostics()}),N.on(Z.Event.CodeAction,({ctx:_,request:K})=>{_.currentUri=K.params.textDocument.uri,_.send({id:K.id,result:V.map((O)=>({title:O.label,kind:"quickfix",diagnostics:[],command:{title:O.label,command:O.key,arguments:[{range:K.params.range,query:O.query}]}}))})})};var _N=(N)=>{N.on(Z.Event.Completion,async({ctx:K,request:O})=>{const R=K.buffers[O.params.textDocument.uri].version;h("completion",()=>{_({ctx:K,request:O,lastContentVersion:R})},200)});const _=async({ctx:K,request:O,lastContentVersion:R})=>{const z=()=>{K.resetDiagnostics(),K.send({id:O.id,result:{isIncomplete:!1,items:[]}})},$=K.buffers[O.params.textDocument.uri];if(Y("running completion on buffer",JSON.stringify($)),$.version>R)return Y("skipping because content is stale"),z();const{lastLine:j,contentBefore:P,contentAfter:U}=await f($.text,O.params.position.line,O.params.position.character);Y("calling completion event"),K.sendDiagnostics([{message:"Fetching completion...",severity:Z.DiagnosticSeverity.Information,range:{start:{line:O.params.position.line,character:0},end:{line:O.params.position.line+1,character:0}}}],1e4);try{var G=await l({contentBefore:P,contentAfter:U},K.currentUri,$?.languageId)}catch(F){return K.sendDiagnostics([{message:F.message,severity:Z.DiagnosticSeverity.Error,range:{start:{line:O.params.position.line,character:0},end:{line:O.params.position.line+1,character:0}}}],1e4)}const T=G?.map((F)=>{if(F.startsWith(j.trim()))F=F.slice(j.trim().length);const I=F.split("\n"),Q=O.params.position.line+I.length-1;let M=I.slice(-1)[0].length;if(Q==O.params.position.line)M+=O.params.position.character;return{label:F.split("\n")[0],kind:1,preselect:!0,detail:F,insertText:F,insertTextFormat:1,additionalTextEdits:[{newText:"",range:{start:{line:Q,character:M},end:{line:Q,character:200}}}]}});K.send({id:O.id,result:{isIncomplete:!0,items:T}}),K.resetDiagnostics()}};var c=new Z.Service({capabilities:{codeActionProvider:!0,executeCommandProvider:{commands:V.map((N)=>N.key)},completionProvider:{resolveProvider:!1,triggerCharacters:["{","("," ","."]},textDocumentSync:{change:2,openClose:!0}}});c.registerEventHandlers(H);try{await c.start()}catch(N){Y("lsp-service error",N.message)}
